import { Component, EventEmitter, Input, Output } from "@angular/core";
import { NgxMatTimepickerUnits } from "../../models/ngx-mat-timepicker-units.enum";
import { NgxMatTimepickerUtils } from "../../utils/ngx-mat-timepicker.utils";
import { NgxMatTimepickerFaceComponent } from "../ngx-mat-timepicker-face/ngx-mat-timepicker-face.component";
import * as i0 from "@angular/core";
export class NgxMatTimepickerMinutesFaceComponent {
    set color(newValue) {
        this._color = newValue;
    }
    get color() {
        return this._color;
    }
    constructor() {
        this.minuteChange = new EventEmitter();
        this.minutesList = [];
        this.timeUnit = NgxMatTimepickerUnits;
        this._color = "primary";
    }
    ngOnChanges(changes) {
        // tslint:disable-next-line:no-string-literal
        if (changes["period"] && changes["period"].currentValue) {
            const minutes = NgxMatTimepickerUtils.getMinutes(this.minutesGap);
            this.minutesList = NgxMatTimepickerUtils.disableMinutes(minutes, this.selectedHour, {
                min: this.minTime,
                max: this.maxTime,
                format: this.format,
                period: this.period
            });
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.5", ngImport: i0, type: NgxMatTimepickerMinutesFaceComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.0.5", type: NgxMatTimepickerMinutesFaceComponent, isStandalone: true, selector: "ngx-mat-timepicker-minutes-face", inputs: { color: "color", dottedMinutesInGap: "dottedMinutesInGap", format: "format", maxTime: "maxTime", minTime: "minTime", minutesGap: "minutesGap", period: "period", selectedHour: "selectedHour", selectedMinute: "selectedMinute" }, outputs: { minuteChange: "minuteChange" }, usesOnChanges: true, ngImport: i0, template: "<ngx-mat-timepicker-face [color]=\"color\"\r\n\t\t\t\t\t\t [dottedMinutesInGap]=\"dottedMinutesInGap\"\r\n\t\t\t\t\t\t [faceTime]=\"minutesList\"\r\n\t\t\t\t\t\t [selectedTime]=\"selectedMinute\"\r\n\t\t\t\t\t\t [minutesGap]=\"minutesGap\"\r\n\t\t\t\t\t\t (timeChange)=\"minuteChange.next($event)\"\r\n\t\t\t\t\t\t [unit]=\"timeUnit.MINUTE\"></ngx-mat-timepicker-face>\r\n", dependencies: [{ kind: "component", type: NgxMatTimepickerFaceComponent, selector: "ngx-mat-timepicker-face", inputs: ["color", "dottedMinutesInGap", "faceTime", "format", "minutesGap", "selectedTime", "unit"], outputs: ["timeChange", "timeSelected"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.5", ngImport: i0, type: NgxMatTimepickerMinutesFaceComponent, decorators: [{
            type: Component,
            args: [{ selector: "ngx-mat-timepicker-minutes-face", standalone: true, imports: [NgxMatTimepickerFaceComponent], template: "<ngx-mat-timepicker-face [color]=\"color\"\r\n\t\t\t\t\t\t [dottedMinutesInGap]=\"dottedMinutesInGap\"\r\n\t\t\t\t\t\t [faceTime]=\"minutesList\"\r\n\t\t\t\t\t\t [selectedTime]=\"selectedMinute\"\r\n\t\t\t\t\t\t [minutesGap]=\"minutesGap\"\r\n\t\t\t\t\t\t (timeChange)=\"minuteChange.next($event)\"\r\n\t\t\t\t\t\t [unit]=\"timeUnit.MINUTE\"></ngx-mat-timepicker-face>\r\n" }]
        }], ctorParameters: () => [], propDecorators: { color: [{
                type: Input
            }], dottedMinutesInGap: [{
                type: Input
            }], format: [{
                type: Input
            }], maxTime: [{
                type: Input
            }], minTime: [{
                type: Input
            }], minuteChange: [{
                type: Output
            }], minutesGap: [{
                type: Input
            }], period: [{
                type: Input
            }], selectedHour: [{
                type: Input
            }], selectedMinute: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LW1hdC10aW1lcGlja2VyLW1pbnV0ZXMtZmFjZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtbWF0LXRpbWVwaWNrZXIvc3JjL2xpYi9jb21wb25lbnRzL25neC1tYXQtdGltZXBpY2tlci1taW51dGVzLWZhY2Uvbmd4LW1hdC10aW1lcGlja2VyLW1pbnV0ZXMtZmFjZS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtbWF0LXRpbWVwaWNrZXIvc3JjL2xpYi9jb21wb25lbnRzL25neC1tYXQtdGltZXBpY2tlci1taW51dGVzLWZhY2Uvbmd4LW1hdC10aW1lcGlja2VyLW1pbnV0ZXMtZmFjZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsU0FBUyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQWEsTUFBTSxFQUFnQixNQUFNLGVBQWUsQ0FBQztBQUsvRixPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSw0Q0FBNEMsQ0FBQztBQUVqRixPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSxzQ0FBc0MsQ0FBQztBQUMzRSxPQUFPLEVBQUMsNkJBQTZCLEVBQUMsTUFBTSw4REFBOEQsQ0FBQzs7QUFVM0csTUFBTSxPQUFPLG9DQUFvQztJQUU3QyxJQUNJLEtBQUssQ0FBQyxRQUFzQjtRQUM1QixJQUFJLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQztJQUMzQixDQUFDO0lBRUQsSUFBSSxLQUFLO1FBQ0wsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3ZCLENBQUM7SUFtQkQ7UUFaVSxpQkFBWSxHQUFHLElBQUksWUFBWSxFQUE2QixDQUFDO1FBR3ZFLGdCQUFXLEdBQWdDLEVBQUUsQ0FBQztRQUs5QyxhQUFRLEdBQUcscUJBQXFCLENBQUM7UUFFekIsV0FBTSxHQUFpQixTQUFTLENBQUM7SUFHekMsQ0FBQztJQUVELFdBQVcsQ0FBQyxPQUFzQjtRQUM5Qiw2Q0FBNkM7UUFDN0MsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ3RELE1BQU0sT0FBTyxHQUFHLHFCQUFxQixDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDbEUsSUFBSSxDQUFDLFdBQVcsR0FBRyxxQkFBcUIsQ0FBQyxjQUFjLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQ2hGLEdBQUcsRUFBRSxJQUFJLENBQUMsT0FBTztnQkFDakIsR0FBRyxFQUFFLElBQUksQ0FBQyxPQUFPO2dCQUNqQixNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07Z0JBQ25CLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTthQUN0QixDQUFDLENBQUM7UUFDUCxDQUFDO0lBQ0wsQ0FBQzs4R0ExQ1Esb0NBQW9DO2tHQUFwQyxvQ0FBb0MsdVlDbEJqRCxzWEFPQSw0Q0RTYyw2QkFBNkI7OzJGQUU5QixvQ0FBb0M7a0JBTmhELFNBQVM7K0JBQ0ksaUNBQWlDLGNBRS9CLElBQUksV0FDUCxDQUFDLDZCQUE2QixDQUFDO3dEQUtwQyxLQUFLO3NCQURSLEtBQUs7Z0JBU0csa0JBQWtCO3NCQUExQixLQUFLO2dCQUNHLE1BQU07c0JBQWQsS0FBSztnQkFDRyxPQUFPO3NCQUFmLEtBQUs7Z0JBQ0csT0FBTztzQkFBZixLQUFLO2dCQUVJLFlBQVk7c0JBQXJCLE1BQU07Z0JBQ0UsVUFBVTtzQkFBbEIsS0FBSztnQkFHRyxNQUFNO3NCQUFkLEtBQUs7Z0JBQ0csWUFBWTtzQkFBcEIsS0FBSztnQkFFRyxjQUFjO3NCQUF0QixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uQ2hhbmdlcywgT3V0cHV0LCBTaW1wbGVDaGFuZ2VzfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xyXG5pbXBvcnQge1RoZW1lUGFsZXR0ZX0gZnJvbSBcIkBhbmd1bGFyL21hdGVyaWFsL2NvcmVcIjtcclxuLy9cclxuaW1wb3J0IHtOZ3hNYXRUaW1lcGlja2VyQ2xvY2tGYWNlfSBmcm9tIFwiLi4vLi4vbW9kZWxzL25neC1tYXQtdGltZXBpY2tlci1jbG9jay1mYWNlLmludGVyZmFjZVwiO1xyXG5pbXBvcnQge05neE1hdFRpbWVwaWNrZXJGb3JtYXRUeXBlfSBmcm9tIFwiLi4vLi4vbW9kZWxzL25neC1tYXQtdGltZXBpY2tlci1mb3JtYXQudHlwZVwiO1xyXG5pbXBvcnQge05neE1hdFRpbWVwaWNrZXJVbml0c30gZnJvbSBcIi4uLy4uL21vZGVscy9uZ3gtbWF0LXRpbWVwaWNrZXItdW5pdHMuZW51bVwiO1xyXG5pbXBvcnQge05neE1hdFRpbWVwaWNrZXJQZXJpb2RzfSBmcm9tIFwiLi4vLi4vbW9kZWxzL25neC1tYXQtdGltZXBpY2tlci1wZXJpb2RzLmVudW1cIjtcclxuaW1wb3J0IHtOZ3hNYXRUaW1lcGlja2VyVXRpbHN9IGZyb20gXCIuLi8uLi91dGlscy9uZ3gtbWF0LXRpbWVwaWNrZXIudXRpbHNcIjtcclxuaW1wb3J0IHtOZ3hNYXRUaW1lcGlja2VyRmFjZUNvbXBvbmVudH0gZnJvbSBcIi4uL25neC1tYXQtdGltZXBpY2tlci1mYWNlL25neC1tYXQtdGltZXBpY2tlci1mYWNlLmNvbXBvbmVudFwiO1xyXG4vL1xyXG5pbXBvcnQge0RhdGVUaW1lfSBmcm9tIFwidHMtbHV4b25cIjtcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6IFwibmd4LW1hdC10aW1lcGlja2VyLW1pbnV0ZXMtZmFjZVwiLFxyXG4gICAgdGVtcGxhdGVVcmw6IFwiLi9uZ3gtbWF0LXRpbWVwaWNrZXItbWludXRlcy1mYWNlLmNvbXBvbmVudC5odG1sXCIsXHJcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxyXG4gICAgaW1wb3J0czogW05neE1hdFRpbWVwaWNrZXJGYWNlQ29tcG9uZW50XVxyXG59KVxyXG5leHBvcnQgY2xhc3MgTmd4TWF0VGltZXBpY2tlck1pbnV0ZXNGYWNlQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgc2V0IGNvbG9yKG5ld1ZhbHVlOiBUaGVtZVBhbGV0dGUpIHtcclxuICAgICAgICB0aGlzLl9jb2xvciA9IG5ld1ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBjb2xvcigpOiBUaGVtZVBhbGV0dGUge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvcjtcclxuICAgIH1cclxuXHJcbiAgICBASW5wdXQoKSBkb3R0ZWRNaW51dGVzSW5HYXA6IGJvb2xlYW47XHJcbiAgICBASW5wdXQoKSBmb3JtYXQ6IE5neE1hdFRpbWVwaWNrZXJGb3JtYXRUeXBlO1xyXG4gICAgQElucHV0KCkgbWF4VGltZTogRGF0ZVRpbWU7XHJcbiAgICBASW5wdXQoKSBtaW5UaW1lOiBEYXRlVGltZTtcclxuXHJcbiAgICBAT3V0cHV0KCkgbWludXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxOZ3hNYXRUaW1lcGlja2VyQ2xvY2tGYWNlPigpO1xyXG4gICAgQElucHV0KCkgbWludXRlc0dhcDogbnVtYmVyO1xyXG5cclxuICAgIG1pbnV0ZXNMaXN0OiBOZ3hNYXRUaW1lcGlja2VyQ2xvY2tGYWNlW10gPSBbXTtcclxuICAgIEBJbnB1dCgpIHBlcmlvZDogTmd4TWF0VGltZXBpY2tlclBlcmlvZHM7XHJcbiAgICBASW5wdXQoKSBzZWxlY3RlZEhvdXI6IG51bWJlcjtcclxuXHJcbiAgICBASW5wdXQoKSBzZWxlY3RlZE1pbnV0ZTogTmd4TWF0VGltZXBpY2tlckNsb2NrRmFjZTtcclxuICAgIHRpbWVVbml0ID0gTmd4TWF0VGltZXBpY2tlclVuaXRzO1xyXG5cclxuICAgIHByaXZhdGUgX2NvbG9yOiBUaGVtZVBhbGV0dGUgPSBcInByaW1hcnlcIjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIH1cclxuXHJcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXN0cmluZy1saXRlcmFsXHJcbiAgICAgICAgaWYgKGNoYW5nZXNbXCJwZXJpb2RcIl0gJiYgY2hhbmdlc1tcInBlcmlvZFwiXS5jdXJyZW50VmFsdWUpIHtcclxuICAgICAgICAgICAgY29uc3QgbWludXRlcyA9IE5neE1hdFRpbWVwaWNrZXJVdGlscy5nZXRNaW51dGVzKHRoaXMubWludXRlc0dhcCk7XHJcbiAgICAgICAgICAgIHRoaXMubWludXRlc0xpc3QgPSBOZ3hNYXRUaW1lcGlja2VyVXRpbHMuZGlzYWJsZU1pbnV0ZXMobWludXRlcywgdGhpcy5zZWxlY3RlZEhvdXIsIHtcclxuICAgICAgICAgICAgICAgIG1pbjogdGhpcy5taW5UaW1lLFxyXG4gICAgICAgICAgICAgICAgbWF4OiB0aGlzLm1heFRpbWUsXHJcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IHRoaXMuZm9ybWF0LFxyXG4gICAgICAgICAgICAgICAgcGVyaW9kOiB0aGlzLnBlcmlvZFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbiIsIjxuZ3gtbWF0LXRpbWVwaWNrZXItZmFjZSBbY29sb3JdPVwiY29sb3JcIlxyXG5cdFx0XHRcdFx0XHQgW2RvdHRlZE1pbnV0ZXNJbkdhcF09XCJkb3R0ZWRNaW51dGVzSW5HYXBcIlxyXG5cdFx0XHRcdFx0XHQgW2ZhY2VUaW1lXT1cIm1pbnV0ZXNMaXN0XCJcclxuXHRcdFx0XHRcdFx0IFtzZWxlY3RlZFRpbWVdPVwic2VsZWN0ZWRNaW51dGVcIlxyXG5cdFx0XHRcdFx0XHQgW21pbnV0ZXNHYXBdPVwibWludXRlc0dhcFwiXHJcblx0XHRcdFx0XHRcdCAodGltZUNoYW5nZSk9XCJtaW51dGVDaGFuZ2UubmV4dCgkZXZlbnQpXCJcclxuXHRcdFx0XHRcdFx0IFt1bml0XT1cInRpbWVVbml0Lk1JTlVURVwiPjwvbmd4LW1hdC10aW1lcGlja2VyLWZhY2U+XHJcbiJdfQ==