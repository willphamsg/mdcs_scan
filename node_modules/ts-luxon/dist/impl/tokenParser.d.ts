import { FormatToken } from "./formatter";
import { Locale } from "./locale";
import { GenericDateTime, ExplainedFormat } from "../types/datetime";
import { Zone } from "../zone";
import Intl from "../types/intl-next";
interface TokenForPart {
    literal: boolean;
    val: string;
}
interface UnitParser {
    deser: (a: string[]) => number | string;
    groups?: number;
    literal?: boolean;
    regex: RegExp;
    token: FormatToken;
}
export declare function expandMacroTokens(tokens: FormatToken[], locale: Locale): Array<FormatToken | TokenForPart>;
/**
 * @private
 */
export declare class TokenParser {
    locale: Locale;
    format: string;
    get invalidReason(): string | null;
    get isValid(): boolean;
    disqualifyingUnit: {
        invalidReason: string;
    };
    handlers: UnitParser[];
    regex: RegExp;
    tokens: Array<FormatToken | TokenForPart>;
    units: UnitParser[];
    constructor(locale: Locale, format: string);
    explainFromTokens(input: string): ExplainedFormat;
    private _mapTokens;
}
export declare function explainFromTokens(locale: Locale, input: string, format: string): ExplainedFormat;
export declare function sanitizeSpaces(input: string): string;
export declare function parseFromTokens(locale: Locale, input: string, format: string): [GenericDateTime | null | void, Zone | null | void, number | undefined, string | void];
export declare function formatOptsToTokens(formatOpts: Intl.DateTimeFormatOptions, locale: Locale): (void | TokenForPart)[];
export {};
