{"version":3,"file":"on-function-explicit-return-type.js","sourceRoot":"","sources":["../../../../../../modules/eslint-plugin/src/rules/store/on-function-explicit-return-type.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,4EAAiE;AACjE,yCAA6B;AAC7B,mDAAgD;AAChD,qCAA6D;AAEhD,QAAA,4BAA4B,GAAG,8BAA8B,CAAC;AAC9D,QAAA,mCAAmC,GAC9C,qCAAqC,CAAC;AAOxC,kBAAe,IAAA,yBAAU,EAAsB;IAC7C,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,IAAI;IACjC,IAAI,EAAE;QACJ,IAAI,EAAE,YAAY;QAClB,cAAc,EAAE,IAAI;QACpB,UAAU,EAAE,OAAO;QACnB,IAAI,EAAE;YACJ,WAAW,EAAE,oDAAoD;YACjE,WAAW,EAAE,MAAM;YACnB,UAAU,EAAE,IAAI;SACjB;QACD,MAAM,EAAE,EAAE;QACV,QAAQ;YACN,GAAC,oCAA4B,IAC3B,mHAAmH;YACrH,GAAC,2CAAmC,IAClC,iIAAiI;eACpI;KACF;IACD,cAAc,EAAE,EAAE;IAClB,MAAM,EAAE,UAAC,OAAO;;QACd,IAAM,UAAU,GAAG,OAAO,CAAC,aAAa,EAAE,CAAC;QAE3C;YACE,GAAC,6BAAqB,IAAtB,UAAwB,IAAsC;gBAC5D,OAAO,CAAC,MAAM,CAAC;oBACb,IAAI,MAAA;oBACJ,SAAS,EAAE,oCAA4B;oBACvC,OAAO,EAAE;wBACP;4BACE,SAAS,EAAE,2CAAmC;4BAC9C,GAAG,EAAE,UAAC,KAAK,IAAK,OAAA,QAAQ,CAAC,IAAI,EAAE,UAAU,EAAE,KAAK,CAAC,EAAjC,CAAiC;yBAClD;qBACF;iBACF,CAAC,CAAC;YACL,CAAC;eACD;IACJ,CAAC;CACF,CAAC,CAAC;AAEH,SAAS,QAAQ,CACf,IAAsC,EACtC,UAAyC,EACzC,KAAyB;IAEjB,IAAA,MAAM,GAAK,IAAI,OAAT,CAAU;IAExB,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QAClB,IAAA,KAAA,OAAmB,UAAU,CAAC,SAAS,CAAC,IAAI,CAAC,IAAA,EAA1C,YAAY,QAA8B,CAAC;QACpD,OAAO,KAAK,CAAC,eAAe,CAAC,YAAY,EAAE,SAAS,CAAC,CAAC;IACxD,CAAC;IAEK,IAAA,KAAA,OAAe,MAAM,IAAA,EAApB,UAAU,QAAU,CAAC;IAC5B,IAAM,SAAS,GAAG,IAAA,eAAO,EAAC,MAAM,CAAC,CAAC;IAClC,IAAM,aAAa,GAAG,UAAU,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;IAC5D,IAAM,eAAe,GACnB,aAAa,IAAI,6BAAQ,CAAC,mBAAmB,CAAC,aAAa,CAAC,CAAC;IAE/D,IAAI,eAAe,EAAE,CAAC;QACpB,IAAM,SAAS,GAAG,UAAU,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;QACtD,OAAO,KAAK,CAAC,eAAe,CAAC,SAAS,aAAT,SAAS,cAAT,SAAS,GAAI,SAAS,EAAE,SAAS,CAAC,CAAC;IAClE,CAAC;IAED,OAAO;QACL,KAAK,CAAC,gBAAgB,CAAC,UAAU,EAAE,GAAG,CAAC;QACvC,KAAK,CAAC,eAAe,CAAC,SAAS,EAAE,UAAU,CAAC;KACpC,CAAC;AACb,CAAC","sourcesContent":["import type { TSESLint, TSESTree } from '@typescript-eslint/experimental-utils';\nimport { ASTUtils } from '@typescript-eslint/experimental-utils';\nimport * as path from 'path';\nimport { createRule } from '../../rule-creator';\nimport { getLast, onFunctionWithoutType } from '../../utils';\n\nexport const onFunctionExplicitReturnType = 'onFunctionExplicitReturnType';\nexport const onFunctionExplicitReturnTypeSuggest =\n  'onFunctionExplicitReturnTypeSuggest';\n\ntype MessageIds =\n  | typeof onFunctionExplicitReturnType\n  | typeof onFunctionExplicitReturnTypeSuggest;\ntype Options = readonly [];\n\nexport default createRule<Options, MessageIds>({\n  name: path.parse(__filename).name,\n  meta: {\n    type: 'suggestion',\n    hasSuggestions: true,\n    ngrxModule: 'store',\n    docs: {\n      description: '`On` function should have an explicit return type.',\n      recommended: 'warn',\n      suggestion: true,\n    },\n    schema: [],\n    messages: {\n      [onFunctionExplicitReturnType]:\n        '`On` functions should have an explicit return type when using arrow functions: `on(action, (state): State => {}`.',\n      [onFunctionExplicitReturnTypeSuggest]:\n        'Add the explicit return type `State` (if the interface/type is named differently you need to manually correct the return type).',\n    },\n  },\n  defaultOptions: [],\n  create: (context) => {\n    const sourceCode = context.getSourceCode();\n\n    return {\n      [onFunctionWithoutType](node: TSESTree.ArrowFunctionExpression) {\n        context.report({\n          node,\n          messageId: onFunctionExplicitReturnType,\n          suggest: [\n            {\n              messageId: onFunctionExplicitReturnTypeSuggest,\n              fix: (fixer) => getFixes(node, sourceCode, fixer),\n            },\n          ],\n        });\n      },\n    };\n  },\n});\n\nfunction getFixes(\n  node: TSESTree.ArrowFunctionExpression,\n  sourceCode: Readonly<TSESLint.SourceCode>,\n  fixer: TSESLint.RuleFixer\n) {\n  const { params } = node;\n\n  if (params.length === 0) {\n    const [, closingParen] = sourceCode.getTokens(node);\n    return fixer.insertTextAfter(closingParen, ': State');\n  }\n\n  const [firstParam] = params;\n  const lastParam = getLast(params);\n  const previousToken = sourceCode.getTokenBefore(firstParam);\n  const isParenthesized =\n    previousToken && ASTUtils.isOpeningParenToken(previousToken);\n\n  if (isParenthesized) {\n    const nextToken = sourceCode.getTokenAfter(lastParam);\n    return fixer.insertTextAfter(nextToken ?? lastParam, ': State');\n  }\n\n  return [\n    fixer.insertTextBefore(firstParam, '('),\n    fixer.insertTextAfter(lastParam, '): State'),\n  ] as const;\n}\n"]}