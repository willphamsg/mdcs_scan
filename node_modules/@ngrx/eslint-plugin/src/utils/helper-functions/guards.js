"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isCallExpressionWith = exports.isTypeReference = exports.isIdentifierOrMemberExpression = exports.isProperty = exports.isObjectExpression = exports.isTSInstantiationExpression = exports.isTSTypeReference = exports.isTSTypeAnnotation = exports.isTSParameterProperty = exports.isThisExpression = exports.isProgram = exports.isMemberExpression = exports.isTemplateLiteral = exports.isTemplateElement = exports.isLiteral = exports.isImportSpecifier = exports.isImportNamespaceSpecifier = exports.isImportDefaultSpecifier = exports.isImportDeclaration = exports.isIdentifier = exports.isFunctionExpression = exports.isPropertyDefinition = exports.isClassDeclaration = exports.isCallExpression = exports.isMethodDefinition = exports.isReturnStatement = exports.isArrowFunctionExpression = void 0;
var experimental_utils_1 = require("@typescript-eslint/experimental-utils");
var isNodeOfType = function (nodeType) {
    return function (node) {
        return node.type === nodeType;
    };
};
exports.isArrowFunctionExpression = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.ArrowFunctionExpression);
exports.isReturnStatement = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.ReturnStatement);
exports.isMethodDefinition = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.MethodDefinition);
exports.isCallExpression = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.CallExpression);
exports.isClassDeclaration = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.ClassDeclaration);
exports.isPropertyDefinition = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.PropertyDefinition);
exports.isFunctionExpression = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.FunctionExpression);
exports.isIdentifier = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.Identifier);
exports.isImportDeclaration = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.ImportDeclaration);
exports.isImportDefaultSpecifier = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.ImportDefaultSpecifier);
exports.isImportNamespaceSpecifier = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.ImportNamespaceSpecifier);
exports.isImportSpecifier = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.ImportSpecifier);
exports.isLiteral = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.Literal);
exports.isTemplateElement = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.TemplateElement);
exports.isTemplateLiteral = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.TemplateLiteral);
exports.isMemberExpression = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.MemberExpression);
exports.isProgram = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.Program);
exports.isThisExpression = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.ThisExpression);
exports.isTSParameterProperty = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.TSParameterProperty);
exports.isTSTypeAnnotation = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.TSTypeAnnotation);
exports.isTSTypeReference = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.TSTypeReference);
exports.isTSInstantiationExpression = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.TSInstantiationExpression);
exports.isObjectExpression = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.ObjectExpression);
exports.isProperty = isNodeOfType(experimental_utils_1.AST_NODE_TYPES.Property);
function isIdentifierOrMemberExpression(node) {
    return (0, exports.isIdentifier)(node) || (0, exports.isMemberExpression)(node);
}
exports.isIdentifierOrMemberExpression = isIdentifierOrMemberExpression;
function isTypeReference(type) {
    return type.hasOwnProperty('target');
}
exports.isTypeReference = isTypeReference;
function equalTo(one, other) {
    return typeof one === 'string' ? one === other : one.test(other);
}
function isCallExpressionWith(node, objectName, propertyName) {
    return ((0, exports.isMemberExpression)(node.callee) &&
        !node.callee.computed &&
        node.callee.property.name === propertyName &&
        (((0, exports.isIdentifier)(node.callee.object) &&
            equalTo(objectName, node.callee.object.name)) ||
            ((0, exports.isMemberExpression)(node.callee.object) &&
                (0, exports.isThisExpression)(node.callee.object.object) &&
                (0, exports.isIdentifier)(node.callee.object.property) &&
                equalTo(objectName, node.callee.object.property.name))));
}
exports.isCallExpressionWith = isCallExpressionWith;
//# sourceMappingURL=guards.js.map