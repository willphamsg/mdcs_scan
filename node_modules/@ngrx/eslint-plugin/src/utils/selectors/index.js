"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapLikeOperatorsImplicitReturn = exports.mapLikeOperatorsExplicitReturn = exports.actionReducerMap = exports.storeActionReducerMap = exports.onFunctionWithoutType = exports.createReducer = exports.dispatchInEffects = exports.dispatchExpression = exports.selectExpression = exports.pipeableSelect = exports.pipeExpression = exports.namedCallableExpression = exports.namedExpression = exports.effectsInNgModuleProviders = exports.effectsInNgModuleImports = exports.ngModuleProviders = exports.ngModuleImports = exports.ngModuleDecorator = exports.metadataProperty = exports.constructorDefinition = exports.actionCreatorPropsComputed = exports.actionCreatorProps = exports.actionCreatorWithLiteral = exports.actionCreator = exports.propertyDefinitionWithEffectDecorator = exports.effectDecorator = exports.createEffectExpression = exports.effectCreator = void 0;
exports.effectCreator = "PropertyDefinition[value.callee.name='createEffect']";
exports.createEffectExpression = "CallExpression[callee.name='createEffect']";
exports.effectDecorator = "Decorator[expression.callee.name='Effect']";
exports.propertyDefinitionWithEffectDecorator = "ClassDeclaration > ClassBody > PropertyDefinition > ".concat(exports.effectDecorator);
exports.actionCreator = "CallExpression[callee.name='createAction']";
exports.actionCreatorWithLiteral = "".concat(exports.actionCreator, "[arguments.0.type='Literal'][arguments.0.raw=/^'/]");
exports.actionCreatorProps = "".concat(exports.actionCreator, " > CallExpression[callee.name='props']");
exports.actionCreatorPropsComputed = "".concat(exports.actionCreatorProps, " > TSTypeParameterInstantiation > :matches(TSTypeReference[typeName.name!='Readonly'], [type=/^TS(.*)(Keyword|Type)$/])");
exports.constructorDefinition = "MethodDefinition[kind='constructor']";
function metadataProperty(key) {
    return "Property:matches([key.name=".concat(key, "][computed=false], [key.value=").concat(key, "], [key.quasis.0.value.raw=").concat(key, "])");
}
exports.metadataProperty = metadataProperty;
exports.ngModuleDecorator = "ClassDeclaration > Decorator > CallExpression[callee.name='NgModule']";
exports.ngModuleImports = "".concat(exports.ngModuleDecorator, " ObjectExpression ").concat(metadataProperty('imports'), " > ArrayExpression");
exports.ngModuleProviders = "".concat(exports.ngModuleDecorator, " ObjectExpression ").concat(metadataProperty('providers'), " > ArrayExpression");
exports.effectsInNgModuleImports = "".concat(exports.ngModuleImports, " CallExpression[callee.object.name='EffectsModule'][callee.property.name=/^for(Root|Feature)$/] ArrayExpression > Identifier");
exports.effectsInNgModuleProviders = "".concat(exports.ngModuleProviders, " Identifier");
var namedExpression = function (name) {
    return ":matches(".concat(exports.constructorDefinition, " CallExpression[callee.object.name=").concat(name, "], CallExpression[callee.object.object.type='ThisExpression'][callee.object.property.name=").concat(name, "])");
};
exports.namedExpression = namedExpression;
var namedCallableExpression = function (name) {
    return ":matches(".concat((0, exports.namedExpression)(name), ", ").concat(exports.constructorDefinition, " CallExpression[callee.object.callee.object.name=").concat(name, "], CallExpression[callee.object.callee.object.object.type='ThisExpression'][callee.object.callee.object.property.name=").concat(name, "])");
};
exports.namedCallableExpression = namedCallableExpression;
var pipeExpression = function (name) {
    return "".concat((0, exports.namedExpression)(name), "[callee.property.name='pipe']");
};
exports.pipeExpression = pipeExpression;
var pipeableSelect = function (name) {
    return "".concat((0, exports.pipeExpression)(name), " CallExpression[callee.name='select']");
};
exports.pipeableSelect = pipeableSelect;
var selectExpression = function (name) {
    return "".concat((0, exports.namedExpression)(name), "[callee.property.name='select']");
};
exports.selectExpression = selectExpression;
var dispatchExpression = function (name) {
    return "".concat((0, exports.namedExpression)(name), "[callee.property.name='dispatch']");
};
exports.dispatchExpression = dispatchExpression;
var dispatchInEffects = function (name) {
    return "".concat(exports.createEffectExpression, " ").concat((0, exports.dispatchExpression)(name), " > MemberExpression:has(Identifier[name=").concat(name, "])");
};
exports.dispatchInEffects = dispatchInEffects;
exports.createReducer = "CallExpression[callee.name='createReducer']";
exports.onFunctionWithoutType = "".concat(exports.createReducer, " CallExpression[callee.name='on'] > ArrowFunctionExpression:not([returnType.typeAnnotation], :has(CallExpression))");
exports.storeActionReducerMap = "".concat(exports.ngModuleImports, " CallExpression[callee.object.name='StoreModule'][callee.property.name=/^for(Root|Feature)$/] > ObjectExpression:first-child");
exports.actionReducerMap = "VariableDeclarator[id.typeAnnotation.typeAnnotation.typeName.name='ActionReducerMap'] > ObjectExpression";
var mapLikeOperators = '/^(concat|exhaust|flat|merge|switch)Map$/';
var mapLikeToOperators = '/^(concat|merge|switch)MapTo$/';
exports.mapLikeOperatorsExplicitReturn = "CallExpression[callee.name=".concat(mapLikeOperators, "] ReturnStatement");
exports.mapLikeOperatorsImplicitReturn = ":matches(CallExpression[callee.name=".concat(mapLikeToOperators, "], CallExpression[callee.name=").concat(mapLikeOperators, "] > ArrowFunctionExpression)");
//# sourceMappingURL=index.js.map