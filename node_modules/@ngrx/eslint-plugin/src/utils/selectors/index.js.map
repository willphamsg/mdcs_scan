{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../../modules/eslint-plugin/src/utils/selectors/index.ts"],"names":[],"mappings":";;;AAAa,QAAA,aAAa,GAAG,sDAAsD,CAAC;AACvE,QAAA,sBAAsB,GAAG,4CAA4C,CAAC;AAEtE,QAAA,eAAe,GAAG,4CAA4C,CAAC;AAC/D,QAAA,qCAAqC,GAChD,8DAAuD,uBAAe,CAAW,CAAC;AAEvE,QAAA,aAAa,GAAG,4CAA4C,CAAC;AAC7D,QAAA,wBAAwB,GACnC,UAAG,qBAAa,uDAA6D,CAAC;AACnE,QAAA,kBAAkB,GAC7B,UAAG,qBAAa,2CAAiD,CAAC;AACvD,QAAA,0BAA0B,GACrC,UAAG,0BAAkB,4HAAkI,CAAC;AAE7I,QAAA,qBAAqB,GAAG,sCAAsC,CAAC;AAM5E,SAAgB,gBAAgB,CAAC,GAAoB;IACnD,OAAO,qCAA8B,GAAG,2CAAiC,GAAG,wCAA8B,GAAG,OAAI,CAAC;AACpH,CAAC;AAFD,4CAEC;AAEY,QAAA,iBAAiB,GAAG,uEAAuE,CAAC;AAE5F,QAAA,eAAe,GAC1B,UAAG,yBAAiB,+BAAqB,gBAAgB,CACvD,SAAS,CACV,uBAA6B,CAAC;AAEpB,QAAA,iBAAiB,GAC5B,UAAG,yBAAiB,+BAAqB,gBAAgB,CACvD,WAAW,CACZ,uBAA6B,CAAC;AAEpB,QAAA,wBAAwB,GACnC,UAAG,uBAAe,iIAAuI,CAAC;AAE/I,QAAA,0BAA0B,GACrC,UAAG,yBAAiB,gBAAsB,CAAC;AAEtC,IAAM,eAAe,GAAG,UAAC,IAAqB;IACnD,OAAA,mBAAY,6BAAqB,gDAAsC,IAAI,uGAA6F,IAAI,OAAa;AAAzL,CAAyL,CAAC;AAD/K,QAAA,eAAe,mBACgK;AAErL,IAAM,uBAAuB,GAAG,UAAC,IAAqB;IAC3D,OAAA,mBAAY,IAAA,uBAAe,EACzB,IAAI,CACL,eAAK,6BAAqB,8DAAoD,IAAI,mIAAyH,IAAI,OAAa;AAF7N,CAE6N,CAAC;AAHnN,QAAA,uBAAuB,2BAG4L;AAEzN,IAAM,cAAc,GAAG,UAAC,IAAqB;IAClD,OAAA,UAAG,IAAA,uBAAe,EAAC,IAAI,CAAC,kCAAwC;AAAhE,CAAgE,CAAC;AADtD,QAAA,cAAc,kBACwC;AAE5D,IAAM,cAAc,GAAG,UAAC,IAAqB;IAClD,OAAA,UAAG,IAAA,sBAAc,EAAC,IAAI,CAAC,0CAAgD;AAAvE,CAAuE,CAAC;AAD7D,QAAA,cAAc,kBAC+C;AAEnE,IAAM,gBAAgB,GAAG,UAAC,IAAqB;IACpD,OAAA,UAAG,IAAA,uBAAe,EAAC,IAAI,CAAC,oCAA0C;AAAlE,CAAkE,CAAC;AADxD,QAAA,gBAAgB,oBACwC;AAE9D,IAAM,kBAAkB,GAAG,UAAC,IAAqB;IACtD,OAAA,UAAG,IAAA,uBAAe,EAAC,IAAI,CAAC,sCAA4C;AAApE,CAAoE,CAAC;AAD1D,QAAA,kBAAkB,sBACwC;AAEhE,IAAM,iBAAiB,GAAG,UAAC,IAAqB;IACrD,OAAA,UAAG,8BAAsB,cAAI,IAAA,0BAAkB,EAC7C,IAAI,CACL,qDAA2C,IAAI,OAAa;AAF7D,CAE6D,CAAC;AAHnD,QAAA,iBAAiB,qBAGkC;AAEnD,QAAA,aAAa,GAAG,6CAA6C,CAAC;AAE9D,QAAA,qBAAqB,GAChC,UAAG,qBAAa,uHAA6H,CAAC;AAEnI,QAAA,qBAAqB,GAChC,UAAG,uBAAe,iIAAuI,CAAC;AAE/I,QAAA,gBAAgB,GAAG,0GAA0G,CAAC;AAE3I,IAAM,gBAAgB,GAAG,2CAA2C,CAAC;AACrE,IAAM,kBAAkB,GAAG,gCAAgC,CAAC;AAC/C,QAAA,8BAA8B,GACzC,qCAA8B,gBAAgB,sBAA4B,CAAC;AAChE,QAAA,8BAA8B,GACzC,8CAAuC,kBAAkB,2CAAiC,gBAAgB,iCAAuC,CAAC","sourcesContent":["export const effectCreator = `PropertyDefinition[value.callee.name='createEffect']`;\nexport const createEffectExpression = `CallExpression[callee.name='createEffect']`;\n\nexport const effectDecorator = `Decorator[expression.callee.name='Effect']`;\nexport const propertyDefinitionWithEffectDecorator =\n  `ClassDeclaration > ClassBody > PropertyDefinition > ${effectDecorator}` as const;\n\nexport const actionCreator = `CallExpression[callee.name='createAction']`;\nexport const actionCreatorWithLiteral =\n  `${actionCreator}[arguments.0.type='Literal'][arguments.0.raw=/^'/]` as const;\nexport const actionCreatorProps =\n  `${actionCreator} > CallExpression[callee.name='props']` as const;\nexport const actionCreatorPropsComputed =\n  `${actionCreatorProps} > TSTypeParameterInstantiation > :matches(TSTypeReference[typeName.name!='Readonly'], [type=/^TS(.*)(Keyword|Type)$/])` as const;\n\nexport const constructorDefinition = `MethodDefinition[kind='constructor']`;\n\nexport function metadataProperty(key: RegExp): string;\nexport function metadataProperty<TKey extends string>(\n  key: TKey\n): `Property:matches([key.name=${TKey}][computed=false], [key.value=${TKey}], [key.quasis.0.value.raw=${TKey}])`;\nexport function metadataProperty(key: RegExp | string): string {\n  return `Property:matches([key.name=${key}][computed=false], [key.value=${key}], [key.quasis.0.value.raw=${key}])`;\n}\n\nexport const ngModuleDecorator = `ClassDeclaration > Decorator > CallExpression[callee.name='NgModule']`;\n\nexport const ngModuleImports =\n  `${ngModuleDecorator} ObjectExpression ${metadataProperty(\n    'imports'\n  )} > ArrayExpression` as const;\n\nexport const ngModuleProviders =\n  `${ngModuleDecorator} ObjectExpression ${metadataProperty(\n    'providers'\n  )} > ArrayExpression` as const;\n\nexport const effectsInNgModuleImports =\n  `${ngModuleImports} CallExpression[callee.object.name='EffectsModule'][callee.property.name=/^for(Root|Feature)$/] ArrayExpression > Identifier` as const;\n\nexport const effectsInNgModuleProviders =\n  `${ngModuleProviders} Identifier` as const;\n\nexport const namedExpression = (name: RegExp | string) =>\n  `:matches(${constructorDefinition} CallExpression[callee.object.name=${name}], CallExpression[callee.object.object.type='ThisExpression'][callee.object.property.name=${name}])` as const;\n\nexport const namedCallableExpression = (name: RegExp | string) =>\n  `:matches(${namedExpression(\n    name\n  )}, ${constructorDefinition} CallExpression[callee.object.callee.object.name=${name}], CallExpression[callee.object.callee.object.object.type='ThisExpression'][callee.object.callee.object.property.name=${name}])` as const;\n\nexport const pipeExpression = (name: RegExp | string) =>\n  `${namedExpression(name)}[callee.property.name='pipe']` as const;\n\nexport const pipeableSelect = (name: RegExp | string) =>\n  `${pipeExpression(name)} CallExpression[callee.name='select']` as const;\n\nexport const selectExpression = (name: RegExp | string) =>\n  `${namedExpression(name)}[callee.property.name='select']` as const;\n\nexport const dispatchExpression = (name: RegExp | string) =>\n  `${namedExpression(name)}[callee.property.name='dispatch']` as const;\n\nexport const dispatchInEffects = (name: RegExp | string) =>\n  `${createEffectExpression} ${dispatchExpression(\n    name\n  )} > MemberExpression:has(Identifier[name=${name}])` as const;\n\nexport const createReducer = `CallExpression[callee.name='createReducer']`;\n\nexport const onFunctionWithoutType =\n  `${createReducer} CallExpression[callee.name='on'] > ArrowFunctionExpression:not([returnType.typeAnnotation], :has(CallExpression))` as const;\n\nexport const storeActionReducerMap =\n  `${ngModuleImports} CallExpression[callee.object.name='StoreModule'][callee.property.name=/^for(Root|Feature)$/] > ObjectExpression:first-child` as const;\n\nexport const actionReducerMap = `VariableDeclarator[id.typeAnnotation.typeAnnotation.typeName.name='ActionReducerMap'] > ObjectExpression`;\n\nconst mapLikeOperators = '/^(concat|exhaust|flat|merge|switch)Map$/';\nconst mapLikeToOperators = '/^(concat|merge|switch)MapTo$/';\nexport const mapLikeOperatorsExplicitReturn =\n  `CallExpression[callee.name=${mapLikeOperators}] ReturnStatement` as const;\nexport const mapLikeOperatorsImplicitReturn =\n  `:matches(CallExpression[callee.name=${mapLikeToOperators}], CallExpression[callee.name=${mapLikeOperators}] > ArrowFunctionExpression)` as const;\n"]}